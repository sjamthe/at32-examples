ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 1
  11              		.eabi_attribute 18, 4
  12              		.file	"subscribe_task.cpp"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.text._Z6led_cbPh,"ax",%progbits
  17              		.align	1
  18              		.global	_Z6led_cbPh
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	_Z6led_cbPh:
  25              		.fnstart
  26              	.LFB469:
  27              		.file 1 "ROSTasks/Src/subscribe_task.cpp"
   1:ROSTasks/Src/subscribe_task.cpp **** /*
   2:ROSTasks/Src/subscribe_task.cpp ****  * subscribe_task.cpp
   3:ROSTasks/Src/subscribe_task.cpp ****  *	Operate led #2
   4:ROSTasks/Src/subscribe_task.cpp ****  *
   5:ROSTasks/Src/subscribe_task.cpp ****  *  Created on: Mar 18, 2019
   6:ROSTasks/Src/subscribe_task.cpp ****  *      Author: Shirish Jamthe
   7:ROSTasks/Src/subscribe_task.cpp ****  * 
   8:ROSTasks/Src/subscribe_task.cpp ****  */
   9:ROSTasks/Src/subscribe_task.cpp **** 
  10:ROSTasks/Src/subscribe_task.cpp **** #include "subscribe_task.h"
  11:ROSTasks/Src/subscribe_task.cpp **** 
  12:ROSTasks/Src/subscribe_task.cpp **** static ros::NodeHandle *nh_;
  13:ROSTasks/Src/subscribe_task.cpp **** 
  14:ROSTasks/Src/subscribe_task.cpp **** void led_cb(unsigned char* cmd_msg);
  15:ROSTasks/Src/subscribe_task.cpp **** 
  16:ROSTasks/Src/subscribe_task.cpp **** //QueueHandle_t subscribeQueueHandle;
  17:ROSTasks/Src/subscribe_task.cpp **** 
  18:ROSTasks/Src/subscribe_task.cpp **** static int useLed = 3;
  19:ROSTasks/Src/subscribe_task.cpp **** 
  20:ROSTasks/Src/subscribe_task.cpp **** //void led_cb(const std_msgs::UInt16& cmd_msg)
  21:ROSTasks/Src/subscribe_task.cpp **** void led_cb(unsigned char* msg)
  22:ROSTasks/Src/subscribe_task.cpp **** {
  28              		.loc 1 22 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 08B5     		push	{r3, lr}
  34              		.save {r3, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 8
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 2


  37              		.cfi_offset 3, -8
  38              		.cfi_offset 14, -4
  39              	.LVL1:
  40              	.LBB25:
  41              	.LBB26:
  42              		.file 2 "../Libraries/ROSSerial/std_msgs/UInt16.h"
   1:../Libraries/ROSSerial/std_msgs/UInt16.h **** #ifndef _ROS_std_msgs_UInt16_h
   2:../Libraries/ROSSerial/std_msgs/UInt16.h **** #define _ROS_std_msgs_UInt16_h
   3:../Libraries/ROSSerial/std_msgs/UInt16.h **** 
   4:../Libraries/ROSSerial/std_msgs/UInt16.h **** #include <stdint.h>
   5:../Libraries/ROSSerial/std_msgs/UInt16.h **** #include <string.h>
   6:../Libraries/ROSSerial/std_msgs/UInt16.h **** #include <stdlib.h>
   7:../Libraries/ROSSerial/std_msgs/UInt16.h **** #include "ros/msg.h"
   8:../Libraries/ROSSerial/std_msgs/UInt16.h **** 
   9:../Libraries/ROSSerial/std_msgs/UInt16.h **** namespace std_msgs
  10:../Libraries/ROSSerial/std_msgs/UInt16.h **** {
  11:../Libraries/ROSSerial/std_msgs/UInt16.h **** 
  12:../Libraries/ROSSerial/std_msgs/UInt16.h ****   class UInt16 : public ros::Msg
  13:../Libraries/ROSSerial/std_msgs/UInt16.h ****   {
  14:../Libraries/ROSSerial/std_msgs/UInt16.h ****     public:
  15:../Libraries/ROSSerial/std_msgs/UInt16.h ****       uint16_t data;
  16:../Libraries/ROSSerial/std_msgs/UInt16.h **** 
  17:../Libraries/ROSSerial/std_msgs/UInt16.h ****     virtual int serialize(unsigned char *outbuffer) const
  18:../Libraries/ROSSerial/std_msgs/UInt16.h ****     {
  19:../Libraries/ROSSerial/std_msgs/UInt16.h ****       int offset = 0;
  20:../Libraries/ROSSerial/std_msgs/UInt16.h ****       *(outbuffer + offset + 0) = (this->data >> (8 * 0)) & 0xFF;
  21:../Libraries/ROSSerial/std_msgs/UInt16.h ****       *(outbuffer + offset + 1) = (this->data >> (8 * 1)) & 0xFF;
  22:../Libraries/ROSSerial/std_msgs/UInt16.h ****       offset += sizeof(this->data);
  23:../Libraries/ROSSerial/std_msgs/UInt16.h ****       return offset;
  24:../Libraries/ROSSerial/std_msgs/UInt16.h ****     }
  25:../Libraries/ROSSerial/std_msgs/UInt16.h **** 
  26:../Libraries/ROSSerial/std_msgs/UInt16.h ****     virtual int deserialize(unsigned char *inbuffer)
  27:../Libraries/ROSSerial/std_msgs/UInt16.h ****     {
  28:../Libraries/ROSSerial/std_msgs/UInt16.h ****       int offset = 0;
  29:../Libraries/ROSSerial/std_msgs/UInt16.h ****       this->data =  ((uint16_t) (*(inbuffer + offset)));
  43              		.loc 2 29 0
  44 0002 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
  30:../Libraries/ROSSerial/std_msgs/UInt16.h ****       this->data |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
  45              		.loc 2 30 0
  46 0004 4278     		ldrb	r2, [r0, #1]	@ zero_extendqisi2
  47              	.LVL2:
  48              	.LBE26:
  49              	.LBE25:
  23:ROSTasks/Src/subscribe_task.cpp **** 	const std_msgs::UInt16 cmd_msg;
  24:ROSTasks/Src/subscribe_task.cpp **** 	cmd_msg.deserialize(msg);
  25:ROSTasks/Src/subscribe_task.cpp **** 	int16_t ledState = cmd_msg.data;
  26:ROSTasks/Src/subscribe_task.cpp **** 	//xQueueSend( subscribeQueueHandle, (uint16_t*)&cmd_msg.data, portMAX_DELAY);
  27:ROSTasks/Src/subscribe_task.cpp **** 	switch(ledState)
  50              		.loc 1 27 0
  51 0006 53EA0223 		orrs	r3, r3, r2, lsl #8
  52              	.LVL3:
  53 000a 02D0     		beq	.L3
  54 000c 012B     		cmp	r3, #1
  55 000e 04D0     		beq	.L4
  56              	.LVL4:
  57              	.L1:
  28:ROSTasks/Src/subscribe_task.cpp **** 	{
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 3


  29:ROSTasks/Src/subscribe_task.cpp **** 		case 0: bsp_LedOff(2); break;
  30:ROSTasks/Src/subscribe_task.cpp **** 		case 1: bsp_LedOn(2); break;
  31:ROSTasks/Src/subscribe_task.cpp **** 	}
  32:ROSTasks/Src/subscribe_task.cpp **** 	useLed = 2;
  33:ROSTasks/Src/subscribe_task.cpp **** }
  58              		.loc 1 33 0
  59 0010 08BD     		pop	{r3, pc}
  60              	.LVL5:
  61              	.L3:
  29:ROSTasks/Src/subscribe_task.cpp **** 		case 1: bsp_LedOn(2); break;
  62              		.loc 1 29 0
  63 0012 0220     		movs	r0, #2
  64              	.LVL6:
  65 0014 FFF7FEFF 		bl	bsp_LedOff
  66              	.LVL7:
  67 0018 FAE7     		b	.L1
  68              	.LVL8:
  69              	.L4:
  30:ROSTasks/Src/subscribe_task.cpp **** 	}
  70              		.loc 1 30 0
  71 001a 0220     		movs	r0, #2
  72              	.LVL9:
  73 001c FFF7FEFF 		bl	bsp_LedOn
  74              	.LVL10:
  75              		.loc 1 33 0
  76 0020 F6E7     		b	.L1
  77              		.cfi_endproc
  78              	.LFE469:
  79              		.fnend
  81              		.section	.text._Z24ROS_SubscribeTaskHandlerPKv,"ax",%progbits
  82              		.align	1
  83              		.global	_Z24ROS_SubscribeTaskHandlerPKv
  84              		.syntax unified
  85              		.thumb
  86              		.thumb_func
  87              		.fpu fpv4-sp-d16
  89              	_Z24ROS_SubscribeTaskHandlerPKv:
  90              		.fnstart
  91              	.LFB476:
  34:ROSTasks/Src/subscribe_task.cpp **** 
  35:ROSTasks/Src/subscribe_task.cpp **** void ROS_SubscribeTaskHandler(void const * argument)
  36:ROSTasks/Src/subscribe_task.cpp **** {
  92              		.loc 1 36 0
  93              		.cfi_startproc
  94              		@ args = 0, pretend = 0, frame = 0
  95              		@ frame_needed = 0, uses_anonymous_args = 0
  96              	.LVL11:
  97 0000 08B5     		push	{r3, lr}
  98              		.save {r3, lr}
  99              	.LCFI1:
 100              		.cfi_def_cfa_offset 8
 101              		.cfi_offset 3, -8
 102              		.cfi_offset 14, -4
 103              	.LVL12:
 104              	.L7:
  37:ROSTasks/Src/subscribe_task.cpp **** 
  38:ROSTasks/Src/subscribe_task.cpp ****   /* USER CODE BEGIN ROS_SpinTaskHandler */
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 4


  39:ROSTasks/Src/subscribe_task.cpp **** 
  40:ROSTasks/Src/subscribe_task.cpp ****   /* Infinite loop */
  41:ROSTasks/Src/subscribe_task.cpp ****   for(;;)
  42:ROSTasks/Src/subscribe_task.cpp ****   {
  43:ROSTasks/Src/subscribe_task.cpp **** 	//   if(xQueueReceive( subscribeQueueHandle, &ledState, portMAX_DELAY))
  44:ROSTasks/Src/subscribe_task.cpp **** 	//   {
  45:ROSTasks/Src/subscribe_task.cpp **** 	// 	  switch(ledState)
  46:ROSTasks/Src/subscribe_task.cpp **** 	// 	  {
  47:ROSTasks/Src/subscribe_task.cpp **** 	// 		case 0: bsp_LedOff(2); break;
  48:ROSTasks/Src/subscribe_task.cpp **** 	//    	  	case 1: bsp_LedOn(2); break;
  49:ROSTasks/Src/subscribe_task.cpp **** 	// 	  }
  50:ROSTasks/Src/subscribe_task.cpp **** 	//   }
  51:ROSTasks/Src/subscribe_task.cpp **** 	//   else 
  52:ROSTasks/Src/subscribe_task.cpp **** 	//   {
  53:ROSTasks/Src/subscribe_task.cpp **** 		//bsp_LedToggle(useLed);
  54:ROSTasks/Src/subscribe_task.cpp **** 		osDelay(100);
 105              		.loc 1 54 0 discriminator 1
 106 0002 6420     		movs	r0, #100
 107 0004 FFF7FEFF 		bl	osDelay
 108              	.LVL13:
 109 0008 FBE7     		b	.L7
 110              		.cfi_endproc
 111              	.LFE476:
 112              		.fnend
 114              		.section	.text._Z20rosSubscribeInitTaskPN3ros11NodeHandle_I13STM32HardwareLi5ELi5ELi512ELi512EEE,"
 115              		.align	1
 116              		.global	_Z20rosSubscribeInitTaskPN3ros11NodeHandle_I13STM32HardwareLi5ELi5ELi512ELi512EEE
 117              		.syntax unified
 118              		.thumb
 119              		.thumb_func
 120              		.fpu fpv4-sp-d16
 122              	_Z20rosSubscribeInitTaskPN3ros11NodeHandle_I13STM32HardwareLi5ELi5ELi512ELi512EEE:
 123              		.fnstart
 124              	.LFB477:
  55:ROSTasks/Src/subscribe_task.cpp **** 	//   }
  56:ROSTasks/Src/subscribe_task.cpp **** 	//   osDelay(100);
  57:ROSTasks/Src/subscribe_task.cpp ****   }
  58:ROSTasks/Src/subscribe_task.cpp **** 
  59:ROSTasks/Src/subscribe_task.cpp ****   /* USER CODE END ROS_SubscribeTaskHandler */
  60:ROSTasks/Src/subscribe_task.cpp **** }
  61:ROSTasks/Src/subscribe_task.cpp **** 
  62:ROSTasks/Src/subscribe_task.cpp **** uint32_t rosSubscribeInitTask(ros::NodeHandle *nh)
  63:ROSTasks/Src/subscribe_task.cpp **** {
 125              		.loc 1 63 0
 126              		.cfi_startproc
 127              		@ args = 0, pretend = 0, frame = 64
 128              		@ frame_needed = 0, uses_anonymous_args = 0
 129              	.LVL14:
 130 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 131              		.save {r4, r5, r6, r7, lr}
 132              	.LCFI2:
 133              		.cfi_def_cfa_offset 20
 134              		.cfi_offset 4, -20
 135              		.cfi_offset 5, -16
 136              		.cfi_offset 6, -12
 137              		.cfi_offset 7, -8
 138              		.cfi_offset 14, -4
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 5


 139              		.pad #68
 140 0002 91B0     		sub	sp, sp, #68
 141              	.LCFI3:
 142              		.cfi_def_cfa_offset 88
 143 0004 0646     		mov	r6, r0
  64:ROSTasks/Src/subscribe_task.cpp **** 
  65:ROSTasks/Src/subscribe_task.cpp **** 	osThreadId ROS_SubscribeTaskHandle;
  66:ROSTasks/Src/subscribe_task.cpp **** 	ros::SubscriberType sub ;
  67:ROSTasks/Src/subscribe_task.cpp **** 
  68:ROSTasks/Src/subscribe_task.cpp **** 	nh_ = nh;
  69:ROSTasks/Src/subscribe_task.cpp **** 	//nh_->subscribe(sub_led);
  70:ROSTasks/Src/subscribe_task.cpp **** 
  71:ROSTasks/Src/subscribe_task.cpp **** 	const std_msgs::UInt16 msg;
  72:ROSTasks/Src/subscribe_task.cpp **** 	sub.topic_name = "led";
 144              		.loc 1 72 0
 145 0006 244B     		ldr	r3, .L18
 146 0008 0C93     		str	r3, [sp, #48]
 147              	.LVL15:
  73:ROSTasks/Src/subscribe_task.cpp **** 	sub.message_type = msg.getType();
 148              		.loc 1 73 0
 149 000a 244B     		ldr	r3, .L18+4
 150 000c 0D93     		str	r3, [sp, #52]
 151              	.LVL16:
  74:ROSTasks/Src/subscribe_task.cpp **** 	sub.md5sum = msg.getMD5();
 152              		.loc 1 74 0
 153 000e 244B     		ldr	r3, .L18+8
 154 0010 0E93     		str	r3, [sp, #56]
  75:ROSTasks/Src/subscribe_task.cpp **** 	sub.callback = led_cb;
 155              		.loc 1 75 0
 156 0012 244F     		ldr	r7, .L18+12
 157 0014 0F97     		str	r7, [sp, #60]
 158              	.LVL17:
 159 0016 01AC     		add	r4, sp, #4
 160 0018 0BAD     		add	r5, sp, #44
 161 001a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 162              	.LVL18:
 163 001c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 164 001e 2760     		str	r7, [r4]
 165              	.LBB27:
 166              	.LBB28:
 167              		.file 3 "../Libraries/ROSSerial/ros/node_handle.h"
   1:../Libraries/ROSSerial/ros/node_handle.h **** /*
   2:../Libraries/ROSSerial/ros/node_handle.h ****  * Software License Agreement (BSD License)
   3:../Libraries/ROSSerial/ros/node_handle.h ****  *
   4:../Libraries/ROSSerial/ros/node_handle.h ****  * Copyright (c) 2011, Willow Garage, Inc.
   5:../Libraries/ROSSerial/ros/node_handle.h ****  * All rights reserved.
   6:../Libraries/ROSSerial/ros/node_handle.h ****  *
   7:../Libraries/ROSSerial/ros/node_handle.h ****  * Redistribution and use in source and binary forms, with or without
   8:../Libraries/ROSSerial/ros/node_handle.h ****  * modification, are permitted provided that the following conditions
   9:../Libraries/ROSSerial/ros/node_handle.h ****  * are met:
  10:../Libraries/ROSSerial/ros/node_handle.h ****  *
  11:../Libraries/ROSSerial/ros/node_handle.h ****  *  * Redistributions of source code must retain the above copyright
  12:../Libraries/ROSSerial/ros/node_handle.h ****  *    notice, this list of conditions and the following disclaimer.
  13:../Libraries/ROSSerial/ros/node_handle.h ****  *  * Redistributions in binary form must reproduce the above
  14:../Libraries/ROSSerial/ros/node_handle.h ****  *    copyright notice, this list of conditions and the following
  15:../Libraries/ROSSerial/ros/node_handle.h ****  *    disclaimer in the documentation and/or other materials provided
  16:../Libraries/ROSSerial/ros/node_handle.h ****  *    with the distribution.
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 6


  17:../Libraries/ROSSerial/ros/node_handle.h ****  *  * Neither the name of Willow Garage, Inc. nor the names of its
  18:../Libraries/ROSSerial/ros/node_handle.h ****  *    contributors may be used to endorse or promote prducts derived
  19:../Libraries/ROSSerial/ros/node_handle.h ****  *    from this software without specific prior written permission.
  20:../Libraries/ROSSerial/ros/node_handle.h ****  *
  21:../Libraries/ROSSerial/ros/node_handle.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  22:../Libraries/ROSSerial/ros/node_handle.h ****  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  23:../Libraries/ROSSerial/ros/node_handle.h ****  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  24:../Libraries/ROSSerial/ros/node_handle.h ****  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  25:../Libraries/ROSSerial/ros/node_handle.h ****  * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  26:../Libraries/ROSSerial/ros/node_handle.h ****  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  27:../Libraries/ROSSerial/ros/node_handle.h ****  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  28:../Libraries/ROSSerial/ros/node_handle.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  29:../Libraries/ROSSerial/ros/node_handle.h ****  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  30:../Libraries/ROSSerial/ros/node_handle.h ****  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  31:../Libraries/ROSSerial/ros/node_handle.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  32:../Libraries/ROSSerial/ros/node_handle.h ****  * POSSIBILITY OF SUCH DAMAGE.
  33:../Libraries/ROSSerial/ros/node_handle.h ****  */
  34:../Libraries/ROSSerial/ros/node_handle.h **** 
  35:../Libraries/ROSSerial/ros/node_handle.h **** #ifndef ROS_NODE_HANDLE_H_
  36:../Libraries/ROSSerial/ros/node_handle.h **** #define ROS_NODE_HANDLE_H_
  37:../Libraries/ROSSerial/ros/node_handle.h **** 
  38:../Libraries/ROSSerial/ros/node_handle.h **** #include <stdint.h>
  39:../Libraries/ROSSerial/ros/node_handle.h **** 
  40:../Libraries/ROSSerial/ros/node_handle.h **** #include "std_msgs/Time.h"
  41:../Libraries/ROSSerial/ros/node_handle.h **** #include "rosserial_msgs/TopicInfo.h"
  42:../Libraries/ROSSerial/ros/node_handle.h **** #include "rosserial_msgs/Log.h"
  43:../Libraries/ROSSerial/ros/node_handle.h **** #include "rosserial_msgs/RequestParam.h"
  44:../Libraries/ROSSerial/ros/node_handle.h **** 
  45:../Libraries/ROSSerial/ros/node_handle.h **** #include "ros/msg.h"
  46:../Libraries/ROSSerial/ros/node_handle.h **** 
  47:../Libraries/ROSSerial/ros/node_handle.h **** namespace ros
  48:../Libraries/ROSSerial/ros/node_handle.h **** {
  49:../Libraries/ROSSerial/ros/node_handle.h **** 
  50:../Libraries/ROSSerial/ros/node_handle.h **** class NodeHandleBase_
  51:../Libraries/ROSSerial/ros/node_handle.h **** {
  52:../Libraries/ROSSerial/ros/node_handle.h **** public:
  53:../Libraries/ROSSerial/ros/node_handle.h ****   virtual int publish(int id, const Msg* msg) = 0;
  54:../Libraries/ROSSerial/ros/node_handle.h ****   virtual int spinOnce() = 0;
  55:../Libraries/ROSSerial/ros/node_handle.h ****   virtual bool connected() = 0;
  56:../Libraries/ROSSerial/ros/node_handle.h **** };
  57:../Libraries/ROSSerial/ros/node_handle.h **** }
  58:../Libraries/ROSSerial/ros/node_handle.h **** 
  59:../Libraries/ROSSerial/ros/node_handle.h **** #include "ros/publisher.h"
  60:../Libraries/ROSSerial/ros/node_handle.h **** #include "ros/subscriber.h"
  61:../Libraries/ROSSerial/ros/node_handle.h **** #include "ros/service_server.h"
  62:../Libraries/ROSSerial/ros/node_handle.h **** #include "ros/service_client.h"
  63:../Libraries/ROSSerial/ros/node_handle.h **** #include "std_msgs/UInt16.h"
  64:../Libraries/ROSSerial/ros/node_handle.h **** 
  65:../Libraries/ROSSerial/ros/node_handle.h **** 
  66:../Libraries/ROSSerial/ros/node_handle.h **** extern void led_cb(unsigned char*);
  67:../Libraries/ROSSerial/ros/node_handle.h **** 
  68:../Libraries/ROSSerial/ros/node_handle.h **** namespace ros
  69:../Libraries/ROSSerial/ros/node_handle.h **** {
  70:../Libraries/ROSSerial/ros/node_handle.h **** 
  71:../Libraries/ROSSerial/ros/node_handle.h **** const int SPIN_OK = 0;
  72:../Libraries/ROSSerial/ros/node_handle.h **** const int SPIN_ERR = -1;
  73:../Libraries/ROSSerial/ros/node_handle.h **** const int SPIN_TIMEOUT = -2;
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 7


  74:../Libraries/ROSSerial/ros/node_handle.h **** 
  75:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t SYNC_SECONDS  = 5;
  76:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t MODE_FIRST_FF = 0;
  77:../Libraries/ROSSerial/ros/node_handle.h **** 
  78:../Libraries/ROSSerial/ros/node_handle.h **** /*
  79:../Libraries/ROSSerial/ros/node_handle.h ****  * The second sync byte is a protocol version. It's value is 0xff for the first
  80:../Libraries/ROSSerial/ros/node_handle.h ****  * version of the rosserial protocol (used up to hydro), 0xfe for the second version
  81:../Libraries/ROSSerial/ros/node_handle.h ****  * (introduced in hydro), 0xfd for the next, and so on. Its purpose is to enable
  82:../Libraries/ROSSerial/ros/node_handle.h ****  * detection of mismatched protocol versions (e.g. hydro rosserial_python with groovy
  83:../Libraries/ROSSerial/ros/node_handle.h ****  * rosserial_arduino. It must be changed in both this file and in
  84:../Libraries/ROSSerial/ros/node_handle.h ****  * rosserial_python/src/rosserial_python/SerialClient.py
  85:../Libraries/ROSSerial/ros/node_handle.h ****  */
  86:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t MODE_PROTOCOL_VER   = 1;
  87:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t PROTOCOL_VER1       = 0xff; // through groovy
  88:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t PROTOCOL_VER2       = 0xfe; // in hydro
  89:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t PROTOCOL_VER        = PROTOCOL_VER2;
  90:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t MODE_SIZE_L         = 2;
  91:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t MODE_SIZE_H         = 3;
  92:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t MODE_SIZE_CHECKSUM  = 4;    // checksum for msg size received from size L and H
  93:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t MODE_TOPIC_L        = 5;    // waiting for topic id
  94:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t MODE_TOPIC_H        = 6;
  95:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t MODE_MESSAGE        = 7;
  96:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t MODE_MSG_CHECKSUM   = 8;    // checksum for msg and topic id
  97:../Libraries/ROSSerial/ros/node_handle.h **** 
  98:../Libraries/ROSSerial/ros/node_handle.h **** 
  99:../Libraries/ROSSerial/ros/node_handle.h **** const uint8_t SERIAL_MSG_TIMEOUT  = 20;   // 20 milliseconds to recieve all of message data
 100:../Libraries/ROSSerial/ros/node_handle.h **** 
 101:../Libraries/ROSSerial/ros/node_handle.h **** using rosserial_msgs::TopicInfo;
 102:../Libraries/ROSSerial/ros/node_handle.h **** 
 103:../Libraries/ROSSerial/ros/node_handle.h **** typedef struct
 104:../Libraries/ROSSerial/ros/node_handle.h **** {
 105:../Libraries/ROSSerial/ros/node_handle.h ****     uint16_t topic_id;
 106:../Libraries/ROSSerial/ros/node_handle.h ****     const char* topic_name;
 107:../Libraries/ROSSerial/ros/node_handle.h ****     const char* message_type;
 108:../Libraries/ROSSerial/ros/node_handle.h ****     const char* md5sum;
 109:../Libraries/ROSSerial/ros/node_handle.h ****     void (*callback)(const Msg& );
 110:../Libraries/ROSSerial/ros/node_handle.h ****     //void * callback;
 111:../Libraries/ROSSerial/ros/node_handle.h **** } SubscriberType;
 112:../Libraries/ROSSerial/ros/node_handle.h **** 
 113:../Libraries/ROSSerial/ros/node_handle.h **** 
 114:../Libraries/ROSSerial/ros/node_handle.h **** /* Node Handle */
 115:../Libraries/ROSSerial/ros/node_handle.h **** template<class Hardware,
 116:../Libraries/ROSSerial/ros/node_handle.h ****          int MAX_SUBSCRIBERS = 25,
 117:../Libraries/ROSSerial/ros/node_handle.h ****          int MAX_PUBLISHERS = 25,
 118:../Libraries/ROSSerial/ros/node_handle.h ****          int INPUT_SIZE = 512,
 119:../Libraries/ROSSerial/ros/node_handle.h ****          int OUTPUT_SIZE = 512>
 120:../Libraries/ROSSerial/ros/node_handle.h **** class NodeHandle_ : public NodeHandleBase_
 121:../Libraries/ROSSerial/ros/node_handle.h **** {
 122:../Libraries/ROSSerial/ros/node_handle.h **** protected:
 123:../Libraries/ROSSerial/ros/node_handle.h ****   Hardware hardware_;
 124:../Libraries/ROSSerial/ros/node_handle.h **** 
 125:../Libraries/ROSSerial/ros/node_handle.h ****   /* time used for syncing */
 126:../Libraries/ROSSerial/ros/node_handle.h ****   uint32_t rt_time;
 127:../Libraries/ROSSerial/ros/node_handle.h **** 
 128:../Libraries/ROSSerial/ros/node_handle.h ****   /* used for computing current time */
 129:../Libraries/ROSSerial/ros/node_handle.h ****   uint32_t sec_offset, nsec_offset;
 130:../Libraries/ROSSerial/ros/node_handle.h **** 
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 8


 131:../Libraries/ROSSerial/ros/node_handle.h ****   /* Spinonce maximum work timeout */
 132:../Libraries/ROSSerial/ros/node_handle.h ****   uint32_t spin_timeout_;
 133:../Libraries/ROSSerial/ros/node_handle.h **** 
 134:../Libraries/ROSSerial/ros/node_handle.h ****   uint8_t message_in[INPUT_SIZE];
 135:../Libraries/ROSSerial/ros/node_handle.h ****   uint8_t message_out[OUTPUT_SIZE];
 136:../Libraries/ROSSerial/ros/node_handle.h **** 
 137:../Libraries/ROSSerial/ros/node_handle.h ****   Publisher * publishers[MAX_PUBLISHERS];
 138:../Libraries/ROSSerial/ros/node_handle.h ****   Subscriber_ * subscribers[MAX_SUBSCRIBERS];
 139:../Libraries/ROSSerial/ros/node_handle.h ****   SubscriberType subscribers2[MAX_SUBSCRIBERS];
 140:../Libraries/ROSSerial/ros/node_handle.h **** 
 141:../Libraries/ROSSerial/ros/node_handle.h ****   /*
 142:../Libraries/ROSSerial/ros/node_handle.h ****    * Setup Functions
 143:../Libraries/ROSSerial/ros/node_handle.h ****    */
 144:../Libraries/ROSSerial/ros/node_handle.h **** public:
 145:../Libraries/ROSSerial/ros/node_handle.h ****   NodeHandle_() : configured_(false)
 146:../Libraries/ROSSerial/ros/node_handle.h ****   {
 147:../Libraries/ROSSerial/ros/node_handle.h **** 
 148:../Libraries/ROSSerial/ros/node_handle.h ****     for (unsigned int i = 0; i < MAX_PUBLISHERS; i++)
 149:../Libraries/ROSSerial/ros/node_handle.h ****       publishers[i] = 0;
 150:../Libraries/ROSSerial/ros/node_handle.h **** 
 151:../Libraries/ROSSerial/ros/node_handle.h ****     for (unsigned int i = 0; i < MAX_SUBSCRIBERS; i++) {
 152:../Libraries/ROSSerial/ros/node_handle.h ****       subscribers[i] = 0;
 153:../Libraries/ROSSerial/ros/node_handle.h ****       subscribers2[i].topic_id = 0;
 154:../Libraries/ROSSerial/ros/node_handle.h ****     }
 155:../Libraries/ROSSerial/ros/node_handle.h **** 
 156:../Libraries/ROSSerial/ros/node_handle.h ****     for (unsigned int i = 0; i < INPUT_SIZE; i++)
 157:../Libraries/ROSSerial/ros/node_handle.h ****       message_in[i] = 0;
 158:../Libraries/ROSSerial/ros/node_handle.h **** 
 159:../Libraries/ROSSerial/ros/node_handle.h ****     for (unsigned int i = 0; i < OUTPUT_SIZE; i++)
 160:../Libraries/ROSSerial/ros/node_handle.h ****       message_out[i] = 0;
 161:../Libraries/ROSSerial/ros/node_handle.h **** 
 162:../Libraries/ROSSerial/ros/node_handle.h ****     req_param_resp.ints_length = 0;
 163:../Libraries/ROSSerial/ros/node_handle.h ****     req_param_resp.ints = NULL;
 164:../Libraries/ROSSerial/ros/node_handle.h ****     req_param_resp.floats_length = 0;
 165:../Libraries/ROSSerial/ros/node_handle.h ****     req_param_resp.floats = NULL;
 166:../Libraries/ROSSerial/ros/node_handle.h ****     req_param_resp.ints_length = 0;
 167:../Libraries/ROSSerial/ros/node_handle.h ****     req_param_resp.ints = NULL;
 168:../Libraries/ROSSerial/ros/node_handle.h **** 
 169:../Libraries/ROSSerial/ros/node_handle.h ****     spin_timeout_ = 0;
 170:../Libraries/ROSSerial/ros/node_handle.h ****   }
 171:../Libraries/ROSSerial/ros/node_handle.h **** 
 172:../Libraries/ROSSerial/ros/node_handle.h ****   Hardware* getHardware()
 173:../Libraries/ROSSerial/ros/node_handle.h ****   {
 174:../Libraries/ROSSerial/ros/node_handle.h ****     return &hardware_;
 175:../Libraries/ROSSerial/ros/node_handle.h ****   }
 176:../Libraries/ROSSerial/ros/node_handle.h **** 
 177:../Libraries/ROSSerial/ros/node_handle.h ****   /* Start serial, initialize buffers */
 178:../Libraries/ROSSerial/ros/node_handle.h ****   void initNode()
 179:../Libraries/ROSSerial/ros/node_handle.h ****   {
 180:../Libraries/ROSSerial/ros/node_handle.h ****     hardware_.init();
 181:../Libraries/ROSSerial/ros/node_handle.h ****     mode_ = 0;
 182:../Libraries/ROSSerial/ros/node_handle.h ****     bytes_ = 0;
 183:../Libraries/ROSSerial/ros/node_handle.h ****     index_ = 0;
 184:../Libraries/ROSSerial/ros/node_handle.h ****     topic_ = 0;
 185:../Libraries/ROSSerial/ros/node_handle.h ****     //printf("Node init\n");
 186:../Libraries/ROSSerial/ros/node_handle.h ****   };
 187:../Libraries/ROSSerial/ros/node_handle.h **** 
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 9


 188:../Libraries/ROSSerial/ros/node_handle.h ****   /* Start a named port, which may be network server IP, initialize buffers */
 189:../Libraries/ROSSerial/ros/node_handle.h ****   void initNode(char *portName)
 190:../Libraries/ROSSerial/ros/node_handle.h ****   {
 191:../Libraries/ROSSerial/ros/node_handle.h ****     hardware_.init(portName);
 192:../Libraries/ROSSerial/ros/node_handle.h ****     mode_ = 0;
 193:../Libraries/ROSSerial/ros/node_handle.h ****     bytes_ = 0;
 194:../Libraries/ROSSerial/ros/node_handle.h ****     index_ = 0;
 195:../Libraries/ROSSerial/ros/node_handle.h ****     topic_ = 0;
 196:../Libraries/ROSSerial/ros/node_handle.h ****   };
 197:../Libraries/ROSSerial/ros/node_handle.h **** 
 198:../Libraries/ROSSerial/ros/node_handle.h ****   /**
 199:../Libraries/ROSSerial/ros/node_handle.h ****    * @brief Sets the maximum time in millisconds that spinOnce() can work.
 200:../Libraries/ROSSerial/ros/node_handle.h ****    * This will not effect the processing of the buffer, as spinOnce processes
 201:../Libraries/ROSSerial/ros/node_handle.h ****    * one byte at a time. It simply sets the maximum time that one call can
 202:../Libraries/ROSSerial/ros/node_handle.h ****    * process for. You can choose to clear the buffer if that is beneficial if
 203:../Libraries/ROSSerial/ros/node_handle.h ****    * SPIN_TIMEOUT is returned from spinOnce().
 204:../Libraries/ROSSerial/ros/node_handle.h ****    * @param timeout The timeout in milliseconds that spinOnce will function.
 205:../Libraries/ROSSerial/ros/node_handle.h ****    */
 206:../Libraries/ROSSerial/ros/node_handle.h ****   void setSpinTimeout(const uint32_t& timeout)
 207:../Libraries/ROSSerial/ros/node_handle.h ****   {
 208:../Libraries/ROSSerial/ros/node_handle.h ****      spin_timeout_ = timeout;
 209:../Libraries/ROSSerial/ros/node_handle.h ****   }
 210:../Libraries/ROSSerial/ros/node_handle.h **** 
 211:../Libraries/ROSSerial/ros/node_handle.h **** protected:
 212:../Libraries/ROSSerial/ros/node_handle.h ****   //State machine variables for spinOnce
 213:../Libraries/ROSSerial/ros/node_handle.h ****   int mode_;
 214:../Libraries/ROSSerial/ros/node_handle.h ****   int bytes_;
 215:../Libraries/ROSSerial/ros/node_handle.h ****   int topic_;
 216:../Libraries/ROSSerial/ros/node_handle.h ****   int index_;
 217:../Libraries/ROSSerial/ros/node_handle.h ****   int checksum_;
 218:../Libraries/ROSSerial/ros/node_handle.h **** 
 219:../Libraries/ROSSerial/ros/node_handle.h ****   bool configured_;
 220:../Libraries/ROSSerial/ros/node_handle.h **** 
 221:../Libraries/ROSSerial/ros/node_handle.h ****   /* used for syncing the time */
 222:../Libraries/ROSSerial/ros/node_handle.h ****   uint32_t last_sync_time;
 223:../Libraries/ROSSerial/ros/node_handle.h ****   uint32_t last_sync_receive_time;
 224:../Libraries/ROSSerial/ros/node_handle.h ****   uint32_t last_msg_timeout_time;
 225:../Libraries/ROSSerial/ros/node_handle.h **** 
 226:../Libraries/ROSSerial/ros/node_handle.h **** public:
 227:../Libraries/ROSSerial/ros/node_handle.h ****   /* This function goes in your loop() function, it handles
 228:../Libraries/ROSSerial/ros/node_handle.h ****    *  serial input and callbacks for subscribers.
 229:../Libraries/ROSSerial/ros/node_handle.h ****    */
 230:../Libraries/ROSSerial/ros/node_handle.h **** 
 231:../Libraries/ROSSerial/ros/node_handle.h ****   virtual int spinOnce() {
 232:../Libraries/ROSSerial/ros/node_handle.h ****     return spinOnce1();
 233:../Libraries/ROSSerial/ros/node_handle.h ****   }
 234:../Libraries/ROSSerial/ros/node_handle.h **** 
 235:../Libraries/ROSSerial/ros/node_handle.h **** //calling spinOnce() directly from spin_task gives stackoverflow
 236:../Libraries/ROSSerial/ros/node_handle.h ****   int spinOnce1()
 237:../Libraries/ROSSerial/ros/node_handle.h ****   {
 238:../Libraries/ROSSerial/ros/node_handle.h ****     static void (*s_CallBack)(char *);
 239:../Libraries/ROSSerial/ros/node_handle.h ****     
 240:../Libraries/ROSSerial/ros/node_handle.h ****     //printf("spinOnce\n");
 241:../Libraries/ROSSerial/ros/node_handle.h ****     /* restart if timed out */
 242:../Libraries/ROSSerial/ros/node_handle.h ****     uint32_t c_time = hardware_.time();
 243:../Libraries/ROSSerial/ros/node_handle.h ****     //printf("spinOnce %ld\n",c_time);
 244:../Libraries/ROSSerial/ros/node_handle.h **** 
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 10


 245:../Libraries/ROSSerial/ros/node_handle.h ****     if ((c_time - last_sync_receive_time) > (SYNC_SECONDS * 2200))
 246:../Libraries/ROSSerial/ros/node_handle.h ****     {
 247:../Libraries/ROSSerial/ros/node_handle.h ****       configured_ = false;
 248:../Libraries/ROSSerial/ros/node_handle.h ****     }
 249:../Libraries/ROSSerial/ros/node_handle.h **** 
 250:../Libraries/ROSSerial/ros/node_handle.h ****     /* reset if message has timed out */
 251:../Libraries/ROSSerial/ros/node_handle.h ****     if (mode_ != MODE_FIRST_FF)
 252:../Libraries/ROSSerial/ros/node_handle.h ****     {
 253:../Libraries/ROSSerial/ros/node_handle.h ****       if (c_time > last_msg_timeout_time)
 254:../Libraries/ROSSerial/ros/node_handle.h ****       {
 255:../Libraries/ROSSerial/ros/node_handle.h ****         mode_ = MODE_FIRST_FF;
 256:../Libraries/ROSSerial/ros/node_handle.h ****       }
 257:../Libraries/ROSSerial/ros/node_handle.h ****     }
 258:../Libraries/ROSSerial/ros/node_handle.h **** 
 259:../Libraries/ROSSerial/ros/node_handle.h ****     /* while available buffer, read data */
 260:../Libraries/ROSSerial/ros/node_handle.h ****     while (true)
 261:../Libraries/ROSSerial/ros/node_handle.h ****     {
 262:../Libraries/ROSSerial/ros/node_handle.h ****       // If a timeout has been specified, check how long spinOnce has been running.
 263:../Libraries/ROSSerial/ros/node_handle.h ****       if (spin_timeout_ > 0)
 264:../Libraries/ROSSerial/ros/node_handle.h ****       {
 265:../Libraries/ROSSerial/ros/node_handle.h ****         // If the maximum processing timeout has been exceeded, exit with error.
 266:../Libraries/ROSSerial/ros/node_handle.h ****         // The next spinOnce can continue where it left off, or optionally
 267:../Libraries/ROSSerial/ros/node_handle.h ****         // based on the application in use, the hardware buffer could be flushed
 268:../Libraries/ROSSerial/ros/node_handle.h ****         // and start fresh.
 269:../Libraries/ROSSerial/ros/node_handle.h ****         if ((hardware_.time() - c_time) > spin_timeout_)
 270:../Libraries/ROSSerial/ros/node_handle.h ****         {
 271:../Libraries/ROSSerial/ros/node_handle.h ****           // Exit the spin, processing timeout exceeded.
 272:../Libraries/ROSSerial/ros/node_handle.h ****           return SPIN_TIMEOUT;
 273:../Libraries/ROSSerial/ros/node_handle.h ****         }
 274:../Libraries/ROSSerial/ros/node_handle.h ****       }
 275:../Libraries/ROSSerial/ros/node_handle.h ****       int data = hardware_.read();
 276:../Libraries/ROSSerial/ros/node_handle.h ****       if (data < 0)
 277:../Libraries/ROSSerial/ros/node_handle.h ****         break;
 278:../Libraries/ROSSerial/ros/node_handle.h ****       checksum_ += data;
 279:../Libraries/ROSSerial/ros/node_handle.h ****       if (mode_ == MODE_MESSAGE)          /* message data being recieved */
 280:../Libraries/ROSSerial/ros/node_handle.h ****       {
 281:../Libraries/ROSSerial/ros/node_handle.h ****         message_in[index_++] = data;
 282:../Libraries/ROSSerial/ros/node_handle.h ****         bytes_--;
 283:../Libraries/ROSSerial/ros/node_handle.h ****         if (bytes_ == 0)                 /* is message complete? if so, checksum */
 284:../Libraries/ROSSerial/ros/node_handle.h ****           mode_ = MODE_MSG_CHECKSUM;
 285:../Libraries/ROSSerial/ros/node_handle.h ****       }
 286:../Libraries/ROSSerial/ros/node_handle.h ****       else if (mode_ == MODE_FIRST_FF)
 287:../Libraries/ROSSerial/ros/node_handle.h ****       {
 288:../Libraries/ROSSerial/ros/node_handle.h ****         if (data == 0xff)
 289:../Libraries/ROSSerial/ros/node_handle.h ****         {
 290:../Libraries/ROSSerial/ros/node_handle.h ****           mode_++;
 291:../Libraries/ROSSerial/ros/node_handle.h ****           last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
 292:../Libraries/ROSSerial/ros/node_handle.h ****         }
 293:../Libraries/ROSSerial/ros/node_handle.h ****         else if (hardware_.time() - c_time > (SYNC_SECONDS * 1000))
 294:../Libraries/ROSSerial/ros/node_handle.h ****         {
 295:../Libraries/ROSSerial/ros/node_handle.h ****           /* We have been stuck in spinOnce too long, return error */
 296:../Libraries/ROSSerial/ros/node_handle.h ****           configured_ = false;
 297:../Libraries/ROSSerial/ros/node_handle.h ****           return SPIN_TIMEOUT;
 298:../Libraries/ROSSerial/ros/node_handle.h ****         }
 299:../Libraries/ROSSerial/ros/node_handle.h ****       }
 300:../Libraries/ROSSerial/ros/node_handle.h ****       else if (mode_ == MODE_PROTOCOL_VER)
 301:../Libraries/ROSSerial/ros/node_handle.h ****       {
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 11


 302:../Libraries/ROSSerial/ros/node_handle.h ****         if (data == PROTOCOL_VER)
 303:../Libraries/ROSSerial/ros/node_handle.h ****         {
 304:../Libraries/ROSSerial/ros/node_handle.h ****           mode_++;
 305:../Libraries/ROSSerial/ros/node_handle.h ****         }
 306:../Libraries/ROSSerial/ros/node_handle.h ****         else
 307:../Libraries/ROSSerial/ros/node_handle.h ****         {
 308:../Libraries/ROSSerial/ros/node_handle.h ****           mode_ = MODE_FIRST_FF;
 309:../Libraries/ROSSerial/ros/node_handle.h ****           if (configured_ == false)
 310:../Libraries/ROSSerial/ros/node_handle.h ****             requestSyncTime();  /* send a msg back showing our protocol version */
 311:../Libraries/ROSSerial/ros/node_handle.h ****         }
 312:../Libraries/ROSSerial/ros/node_handle.h ****       }
 313:../Libraries/ROSSerial/ros/node_handle.h ****       else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
 314:../Libraries/ROSSerial/ros/node_handle.h ****       {
 315:../Libraries/ROSSerial/ros/node_handle.h ****         bytes_ = data;
 316:../Libraries/ROSSerial/ros/node_handle.h ****         index_ = 0;
 317:../Libraries/ROSSerial/ros/node_handle.h ****         mode_++;
 318:../Libraries/ROSSerial/ros/node_handle.h ****         checksum_ = data;               /* first byte for calculating size checksum */
 319:../Libraries/ROSSerial/ros/node_handle.h ****       }
 320:../Libraries/ROSSerial/ros/node_handle.h ****       else if (mode_ == MODE_SIZE_H)      /* top half of message size */
 321:../Libraries/ROSSerial/ros/node_handle.h ****       {
 322:../Libraries/ROSSerial/ros/node_handle.h ****         bytes_ += data << 8;
 323:../Libraries/ROSSerial/ros/node_handle.h ****         mode_++;
 324:../Libraries/ROSSerial/ros/node_handle.h ****       }
 325:../Libraries/ROSSerial/ros/node_handle.h ****       else if (mode_ == MODE_SIZE_CHECKSUM)
 326:../Libraries/ROSSerial/ros/node_handle.h ****       {
 327:../Libraries/ROSSerial/ros/node_handle.h ****         if ((checksum_ % 256) == 255)
 328:../Libraries/ROSSerial/ros/node_handle.h ****           mode_++;
 329:../Libraries/ROSSerial/ros/node_handle.h ****         else
 330:../Libraries/ROSSerial/ros/node_handle.h ****           mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
 331:../Libraries/ROSSerial/ros/node_handle.h ****       }
 332:../Libraries/ROSSerial/ros/node_handle.h ****       else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
 333:../Libraries/ROSSerial/ros/node_handle.h ****       {
 334:../Libraries/ROSSerial/ros/node_handle.h ****         topic_ = data;
 335:../Libraries/ROSSerial/ros/node_handle.h ****         mode_++;
 336:../Libraries/ROSSerial/ros/node_handle.h ****         checksum_ = data;               /* first byte included in checksum */
 337:../Libraries/ROSSerial/ros/node_handle.h ****       }
 338:../Libraries/ROSSerial/ros/node_handle.h ****       else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
 339:../Libraries/ROSSerial/ros/node_handle.h ****       {
 340:../Libraries/ROSSerial/ros/node_handle.h ****         topic_ += data << 8;
 341:../Libraries/ROSSerial/ros/node_handle.h ****         mode_ = MODE_MESSAGE;
 342:../Libraries/ROSSerial/ros/node_handle.h ****         if (bytes_ == 0)
 343:../Libraries/ROSSerial/ros/node_handle.h ****           mode_ = MODE_MSG_CHECKSUM;
 344:../Libraries/ROSSerial/ros/node_handle.h ****       }
 345:../Libraries/ROSSerial/ros/node_handle.h ****       else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
 346:../Libraries/ROSSerial/ros/node_handle.h ****       {
 347:../Libraries/ROSSerial/ros/node_handle.h ****         mode_ = MODE_FIRST_FF;
 348:../Libraries/ROSSerial/ros/node_handle.h ****         if ((checksum_ % 256) == 255)
 349:../Libraries/ROSSerial/ros/node_handle.h ****         {
 350:../Libraries/ROSSerial/ros/node_handle.h ****           if (topic_ == TopicInfo::ID_PUBLISHER)
 351:../Libraries/ROSSerial/ros/node_handle.h ****           {
 352:../Libraries/ROSSerial/ros/node_handle.h ****             requestSyncTime();
 353:../Libraries/ROSSerial/ros/node_handle.h ****             negotiateTopics();
 354:../Libraries/ROSSerial/ros/node_handle.h ****             last_sync_time = c_time;
 355:../Libraries/ROSSerial/ros/node_handle.h ****             last_sync_receive_time = c_time;
 356:../Libraries/ROSSerial/ros/node_handle.h ****             return SPIN_ERR;
 357:../Libraries/ROSSerial/ros/node_handle.h ****           }
 358:../Libraries/ROSSerial/ros/node_handle.h ****           else if (topic_ == TopicInfo::ID_TIME)
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 12


 359:../Libraries/ROSSerial/ros/node_handle.h ****           {
 360:../Libraries/ROSSerial/ros/node_handle.h ****             syncTime(message_in);
 361:../Libraries/ROSSerial/ros/node_handle.h ****           }
 362:../Libraries/ROSSerial/ros/node_handle.h ****           else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
 363:../Libraries/ROSSerial/ros/node_handle.h ****           {
 364:../Libraries/ROSSerial/ros/node_handle.h ****             req_param_resp.deserialize(message_in);
 365:../Libraries/ROSSerial/ros/node_handle.h ****             param_recieved = true;
 366:../Libraries/ROSSerial/ros/node_handle.h ****           }
 367:../Libraries/ROSSerial/ros/node_handle.h ****           else if (topic_ == TopicInfo::ID_TX_STOP)
 368:../Libraries/ROSSerial/ros/node_handle.h ****           {
 369:../Libraries/ROSSerial/ros/node_handle.h ****             configured_ = false;
 370:../Libraries/ROSSerial/ros/node_handle.h ****           }
 371:../Libraries/ROSSerial/ros/node_handle.h ****           else
 372:../Libraries/ROSSerial/ros/node_handle.h ****           {
 373:../Libraries/ROSSerial/ros/node_handle.h ****             if (subscribers2[topic_ - 100].topic_id != 0) {
 374:../Libraries/ROSSerial/ros/node_handle.h ****               //subscribers[topic_ - 100]->callback(message_in);
 375:../Libraries/ROSSerial/ros/node_handle.h ****               s_CallBack = (void (*)(void))subscribers2[topic_ - 100].callback;
 376:../Libraries/ROSSerial/ros/node_handle.h ****               s_CallBack(message_in);
 377:../Libraries/ROSSerial/ros/node_handle.h ****             }
 378:../Libraries/ROSSerial/ros/node_handle.h ****           }
 379:../Libraries/ROSSerial/ros/node_handle.h ****         }
 380:../Libraries/ROSSerial/ros/node_handle.h ****       }
 381:../Libraries/ROSSerial/ros/node_handle.h ****     }
 382:../Libraries/ROSSerial/ros/node_handle.h **** 
 383:../Libraries/ROSSerial/ros/node_handle.h ****     /* occasionally sync time */
 384:../Libraries/ROSSerial/ros/node_handle.h ****     if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
 385:../Libraries/ROSSerial/ros/node_handle.h ****     {
 386:../Libraries/ROSSerial/ros/node_handle.h ****       requestSyncTime();
 387:../Libraries/ROSSerial/ros/node_handle.h ****       last_sync_time = c_time;
 388:../Libraries/ROSSerial/ros/node_handle.h ****     }
 389:../Libraries/ROSSerial/ros/node_handle.h **** 
 390:../Libraries/ROSSerial/ros/node_handle.h ****     return SPIN_OK;
 391:../Libraries/ROSSerial/ros/node_handle.h ****   }
 392:../Libraries/ROSSerial/ros/node_handle.h **** 
 393:../Libraries/ROSSerial/ros/node_handle.h **** 
 394:../Libraries/ROSSerial/ros/node_handle.h ****   /* Are we connected to the PC? */
 395:../Libraries/ROSSerial/ros/node_handle.h ****   virtual bool connected()
 396:../Libraries/ROSSerial/ros/node_handle.h ****   {
 397:../Libraries/ROSSerial/ros/node_handle.h ****     return configured_;
 398:../Libraries/ROSSerial/ros/node_handle.h ****   };
 399:../Libraries/ROSSerial/ros/node_handle.h **** 
 400:../Libraries/ROSSerial/ros/node_handle.h ****   /********************************************************************
 401:../Libraries/ROSSerial/ros/node_handle.h ****    * Time functions
 402:../Libraries/ROSSerial/ros/node_handle.h ****    */
 403:../Libraries/ROSSerial/ros/node_handle.h **** 
 404:../Libraries/ROSSerial/ros/node_handle.h ****   void requestSyncTime()
 405:../Libraries/ROSSerial/ros/node_handle.h ****   {
 406:../Libraries/ROSSerial/ros/node_handle.h ****     std_msgs::Time t;
 407:../Libraries/ROSSerial/ros/node_handle.h ****     publish1(TopicInfo::ID_TIME, &t);
 408:../Libraries/ROSSerial/ros/node_handle.h ****     rt_time = hardware_.time();
 409:../Libraries/ROSSerial/ros/node_handle.h ****   }
 410:../Libraries/ROSSerial/ros/node_handle.h **** 
 411:../Libraries/ROSSerial/ros/node_handle.h ****   void syncTime(uint8_t * data)
 412:../Libraries/ROSSerial/ros/node_handle.h ****   {
 413:../Libraries/ROSSerial/ros/node_handle.h ****     std_msgs::Time t;
 414:../Libraries/ROSSerial/ros/node_handle.h ****     uint32_t offset = hardware_.time() - rt_time;
 415:../Libraries/ROSSerial/ros/node_handle.h **** 
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 13


 416:../Libraries/ROSSerial/ros/node_handle.h ****     t.deserialize(data);
 417:../Libraries/ROSSerial/ros/node_handle.h ****     t.data.sec += offset / 1000;
 418:../Libraries/ROSSerial/ros/node_handle.h ****     t.data.nsec += (offset % 1000) * 1000000UL;
 419:../Libraries/ROSSerial/ros/node_handle.h **** 
 420:../Libraries/ROSSerial/ros/node_handle.h ****     this->setNow(t.data);
 421:../Libraries/ROSSerial/ros/node_handle.h ****     last_sync_receive_time = hardware_.time();
 422:../Libraries/ROSSerial/ros/node_handle.h ****   }
 423:../Libraries/ROSSerial/ros/node_handle.h **** 
 424:../Libraries/ROSSerial/ros/node_handle.h ****   Time now()
 425:../Libraries/ROSSerial/ros/node_handle.h ****   {
 426:../Libraries/ROSSerial/ros/node_handle.h ****     uint32_t ms = hardware_.time();
 427:../Libraries/ROSSerial/ros/node_handle.h ****     Time current_time;
 428:../Libraries/ROSSerial/ros/node_handle.h ****     current_time.sec = ms / 1000 + sec_offset;
 429:../Libraries/ROSSerial/ros/node_handle.h ****     current_time.nsec = (ms % 1000) * 1000000UL + nsec_offset;
 430:../Libraries/ROSSerial/ros/node_handle.h ****     normalizeSecNSec(current_time.sec, current_time.nsec);
 431:../Libraries/ROSSerial/ros/node_handle.h ****     return current_time;
 432:../Libraries/ROSSerial/ros/node_handle.h ****   }
 433:../Libraries/ROSSerial/ros/node_handle.h **** 
 434:../Libraries/ROSSerial/ros/node_handle.h ****   void setNow(Time & new_now)
 435:../Libraries/ROSSerial/ros/node_handle.h ****   {
 436:../Libraries/ROSSerial/ros/node_handle.h ****     uint32_t ms = hardware_.time();
 437:../Libraries/ROSSerial/ros/node_handle.h ****     sec_offset = new_now.sec - ms / 1000 - 1;
 438:../Libraries/ROSSerial/ros/node_handle.h ****     nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
 439:../Libraries/ROSSerial/ros/node_handle.h ****     normalizeSecNSec(sec_offset, nsec_offset);
 440:../Libraries/ROSSerial/ros/node_handle.h ****   }
 441:../Libraries/ROSSerial/ros/node_handle.h **** 
 442:../Libraries/ROSSerial/ros/node_handle.h ****   /********************************************************************
 443:../Libraries/ROSSerial/ros/node_handle.h ****    * Topic Management
 444:../Libraries/ROSSerial/ros/node_handle.h ****    */
 445:../Libraries/ROSSerial/ros/node_handle.h **** 
 446:../Libraries/ROSSerial/ros/node_handle.h ****   /* Register a new publisher */
 447:../Libraries/ROSSerial/ros/node_handle.h ****   bool advertise(Publisher & p)
 448:../Libraries/ROSSerial/ros/node_handle.h ****   {
 449:../Libraries/ROSSerial/ros/node_handle.h ****     for (int i = 0; i < MAX_PUBLISHERS; i++)
 450:../Libraries/ROSSerial/ros/node_handle.h ****     {
 451:../Libraries/ROSSerial/ros/node_handle.h ****       if (publishers[i] == 0) // empty slot
 452:../Libraries/ROSSerial/ros/node_handle.h ****       {
 453:../Libraries/ROSSerial/ros/node_handle.h ****         publishers[i] = &p;
 454:../Libraries/ROSSerial/ros/node_handle.h ****         p.id_ = i + 100 + MAX_SUBSCRIBERS;
 455:../Libraries/ROSSerial/ros/node_handle.h ****         p.nh_ = this;
 456:../Libraries/ROSSerial/ros/node_handle.h ****         return true;
 457:../Libraries/ROSSerial/ros/node_handle.h ****       }
 458:../Libraries/ROSSerial/ros/node_handle.h ****     }
 459:../Libraries/ROSSerial/ros/node_handle.h ****     return false;
 460:../Libraries/ROSSerial/ros/node_handle.h ****   }
 461:../Libraries/ROSSerial/ros/node_handle.h **** 
 462:../Libraries/ROSSerial/ros/node_handle.h ****   /* Register a new subscriber */
 463:../Libraries/ROSSerial/ros/node_handle.h ****   template<typename SubscriberT>
 464:../Libraries/ROSSerial/ros/node_handle.h ****   bool subscribe(SubscriberT& s)
 465:../Libraries/ROSSerial/ros/node_handle.h ****   {
 466:../Libraries/ROSSerial/ros/node_handle.h ****     for (int i = 0; i < MAX_SUBSCRIBERS; i++)
 467:../Libraries/ROSSerial/ros/node_handle.h ****     {
 468:../Libraries/ROSSerial/ros/node_handle.h ****       if (subscribers[i] == 0) // empty slot
 469:../Libraries/ROSSerial/ros/node_handle.h ****       {
 470:../Libraries/ROSSerial/ros/node_handle.h ****         subscribers[i] = static_cast<Subscriber_*>(&s);
 471:../Libraries/ROSSerial/ros/node_handle.h ****         s.id_ = i + 100;
 472:../Libraries/ROSSerial/ros/node_handle.h ****         return true;
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 14


 473:../Libraries/ROSSerial/ros/node_handle.h ****       }
 474:../Libraries/ROSSerial/ros/node_handle.h ****     }
 475:../Libraries/ROSSerial/ros/node_handle.h ****     return false;
 476:../Libraries/ROSSerial/ros/node_handle.h ****   }
 477:../Libraries/ROSSerial/ros/node_handle.h **** 
 478:../Libraries/ROSSerial/ros/node_handle.h ****   bool addSubscriber(SubscriberType sub)
 479:../Libraries/ROSSerial/ros/node_handle.h ****   {
 480:../Libraries/ROSSerial/ros/node_handle.h ****     for (int i = 0; i < MAX_SUBSCRIBERS; i++)
 168              		.loc 3 480 0
 169 0020 0024     		movs	r4, #0
 170              	.L12:
 171              	.LVL19:
 172 0022 042C     		cmp	r4, #4
 173 0024 24DC     		bgt	.L10
 174              	.LBB29:
 481:../Libraries/ROSSerial/ros/node_handle.h ****     {
 482:../Libraries/ROSSerial/ros/node_handle.h ****       if (subscribers2[i].topic_id == 0) {// empty slot}
 175              		.loc 3 482 0
 176 0026 04EB8403 		add	r3, r4, r4, lsl #2
 177 002a 06EB8303 		add	r3, r6, r3, lsl #2
 178 002e B3F84034 		ldrh	r3, [r3, #1088]
 179 0032 0BB1     		cbz	r3, .L16
 180              	.LBE29:
 480:../Libraries/ROSSerial/ros/node_handle.h ****     {
 181              		.loc 3 480 0
 182 0034 0134     		adds	r4, r4, #1
 183              	.LVL20:
 184 0036 F4E7     		b	.L12
 185              	.L16:
 186              	.LBB31:
 187              	.LBB30:
 483:../Libraries/ROSSerial/ros/node_handle.h ****         void * ptr = &subscribers2[i];
 188              		.loc 3 483 0
 189 0038 4FEA840C 		lsl	ip, r4, #2
 190 003c 0CEB0407 		add	r7, ip, r4
 191 0040 BF00     		lsls	r7, r7, #2
 192 0042 07F58867 		add	r7, r7, #1088
 193 0046 06EB070E 		add	lr, r6, r7
 194              	.LVL21:
 484:../Libraries/ROSSerial/ros/node_handle.h ****         memcpy(ptr, &sub, sizeof(sub));
 195              		.loc 3 484 0
 196 004a 01AD     		add	r5, sp, #4
 197 004c 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 198 004e F051     		str	r0, [r6, r7]	@ unaligned
 199 0050 CEF80410 		str	r1, [lr, #4]	@ unaligned
 200 0054 CEF80820 		str	r2, [lr, #8]	@ unaligned
 201 0058 CEF80C30 		str	r3, [lr, #12]	@ unaligned
 202 005c 2868     		ldr	r0, [r5]
 203 005e CEF81000 		str	r0, [lr, #16]	@ unaligned
 485:../Libraries/ROSSerial/ros/node_handle.h ****         subscribers2[i].topic_id = i + 100;
 204              		.loc 3 485 0
 205 0062 04F16403 		add	r3, r4, #100
 206 0066 6444     		add	r4, r4, ip
 207              	.LVL22:
 208 0068 06EB8406 		add	r6, r6, r4, lsl #2
 209              	.LVL23:
 210 006c A6F84034 		strh	r3, [r6, #1088]	@ movhi
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 15


 211              	.LVL24:
 212              	.L10:
 213              	.LBE30:
 214              	.LBE31:
 215              	.LBE28:
 216              	.LBE27:
  76:ROSTasks/Src/subscribe_task.cpp **** 	
  77:ROSTasks/Src/subscribe_task.cpp **** 	nh_->addSubscriber(sub);
  78:ROSTasks/Src/subscribe_task.cpp **** 	
  79:ROSTasks/Src/subscribe_task.cpp **** 	osDelay(10);
 217              		.loc 1 79 0
 218 0070 0A20     		movs	r0, #10
 219 0072 FFF7FEFF 		bl	osDelay
 220              	.LVL25:
  80:ROSTasks/Src/subscribe_task.cpp **** 
  81:ROSTasks/Src/subscribe_task.cpp **** 	/* Create the queue(s) */
  82:ROSTasks/Src/subscribe_task.cpp **** 	/* definition and creation of subscribeQueue */
  83:ROSTasks/Src/subscribe_task.cpp **** 	// subscribeQueueHandle = xQueueCreate( 4, sizeof(uint16_t) );
  84:ROSTasks/Src/subscribe_task.cpp **** 	// if (NULL ==  subscribeQueueHandle)
  85:ROSTasks/Src/subscribe_task.cpp **** 	// {
  86:ROSTasks/Src/subscribe_task.cpp **** 	// 	return 1;
  87:ROSTasks/Src/subscribe_task.cpp **** 	// }
  88:ROSTasks/Src/subscribe_task.cpp **** 
  89:ROSTasks/Src/subscribe_task.cpp **** 	/* definition and creation of ROS_SubscribeTask */
  90:ROSTasks/Src/subscribe_task.cpp **** 	osThreadDef(ROS_SubscribeTask, ROS_SubscribeTaskHandler, osPriorityNormal, 0, 128);
 221              		.loc 1 90 0
 222 0076 06AC     		add	r4, sp, #24
 223 0078 0B4D     		ldr	r5, .L18+16
 224 007a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 225 007c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 226 007e 2B68     		ldr	r3, [r5]
 227 0080 2360     		str	r3, [r4]
  91:ROSTasks/Src/subscribe_task.cpp **** 	ROS_SubscribeTaskHandle = osThreadCreate(osThread(ROS_SubscribeTask), NULL);
 228              		.loc 1 91 0
 229 0082 0021     		movs	r1, #0
 230 0084 06A8     		add	r0, sp, #24
 231 0086 FFF7FEFF 		bl	osThreadCreate
 232              	.LVL26:
  92:ROSTasks/Src/subscribe_task.cpp **** 	if (NULL == ROS_SubscribeTaskHandle)
 233              		.loc 1 92 0
 234 008a 10B1     		cbz	r0, .L17
  93:ROSTasks/Src/subscribe_task.cpp **** 	{
  94:ROSTasks/Src/subscribe_task.cpp **** 	return 1;
  95:ROSTasks/Src/subscribe_task.cpp **** 	}
  96:ROSTasks/Src/subscribe_task.cpp **** 
  97:ROSTasks/Src/subscribe_task.cpp **** 	 return 0;
 235              		.loc 1 97 0
 236 008c 0020     		movs	r0, #0
 237              	.LVL27:
 238              	.L9:
  98:ROSTasks/Src/subscribe_task.cpp **** 
  99:ROSTasks/Src/subscribe_task.cpp **** }
 239              		.loc 1 99 0
 240 008e 11B0     		add	sp, sp, #68
 241              	.LCFI4:
 242              		.cfi_remember_state
 243              		.cfi_def_cfa_offset 20
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 16


 244              		@ sp needed
 245 0090 F0BD     		pop	{r4, r5, r6, r7, pc}
 246              	.LVL28:
 247              	.L17:
 248              	.LCFI5:
 249              		.cfi_restore_state
  94:ROSTasks/Src/subscribe_task.cpp **** 	}
 250              		.loc 1 94 0
 251 0092 0120     		movs	r0, #1
 252              	.LVL29:
 253 0094 FBE7     		b	.L9
 254              	.L19:
 255 0096 00BF     		.align	2
 256              	.L18:
 257 0098 00000000 		.word	.LC2
 258 009c 04000000 		.word	.LC3
 259 00a0 14000000 		.word	.LC4
 260 00a4 00000000 		.word	_Z6led_cbPh
 261 00a8 00000000 		.word	.LANCHOR0
 262              		.cfi_endproc
 263              	.LFE477:
 264              		.fnend
 266              		.section	.rodata
 267              		.align	2
 268              		.set	.LANCHOR0,. + 0
 269              	.LC5:
 270 0000 00000000 		.word	.LC0
 271 0004 00000000 		.word	_Z24ROS_SubscribeTaskHandlerPKv
 272 0008 0000     		.short	0
 273 000a 0000     		.space	2
 274 000c 00000000 		.word	0
 275 0010 80000000 		.word	128
 276              		.section	.rodata._Z20rosSubscribeInitTaskPN3ros11NodeHandle_I13STM32HardwareLi5ELi5ELi512ELi512EEE
 277              		.align	2
 278              	.LC2:
 279 0000 6C656400 		.ascii	"led\000"
 280              	.LC3:
 281 0004 7374645F 		.ascii	"std_msgs/UInt16\000"
 281      6D736773 
 281      2F55496E 
 281      74313600 
 282              	.LC4:
 283 0014 31646637 		.ascii	"1df79edf208b629fe6b81923a544552d\000"
 283      39656466 
 283      32303862 
 283      36323966 
 283      65366238 
 284              		.section	.rodata.str1.4,"aMS",%progbits,1
 285              		.align	2
 286              	.LC0:
 287 0000 524F535F 		.ascii	"ROS_SubscribeTask\000"
 287      53756273 
 287      63726962 
 287      65546173 
 287      6B00
 288              		.text
 289              	.Letext0:
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 17


 290              		.file 4 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h
 291              		.file 5 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 292              		.file 6 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 293              		.file 7 "../Libraries/CMSIS/CM4/CoreSupport/core_cm4.h"
 294              		.file 8 "../Libraries/CMSIS/CM4/DeviceSupport/system_at32f4xx.h"
 295              		.file 9 "Inc/FreeRTOSConfig.h"
 296              		.file 10 "../Middlewares/FreeRTOS//Source/include/task.h"
 297              		.file 11 "../Middlewares/FreeRTOS//Source/CMSIS_RTOS/cmsis_os.h"
 298              		.file 12 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/lock.h"
 299              		.file 13 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_types.h"
 300              		.file 14 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/reent.h"
 301              		.file 15 "../Libraries/ROSSerial/stm32hardware.h"
 302              		.file 16 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/c++/7.3.1/cstdlib"
 303              		.file 17 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/c++/7.3.1/cmath"
 304              		.file 18 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/c++/7.3.1/arm-none-ea
 305              		.file 19 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/stdlib.h"
 306              		.file 20 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/c++/7.3.1/stdlib.h"
 307              		.file 21 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/math.h"
 308              		.file 22 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/c++/7.3.1/math.h"
 309              		.file 23 "<built-in>"
 310              		.file 24 "../Libraries/ROSSerial/ros/msg.h"
 311              		.file 25 "../Libraries/ROSSerial/ros.h"
 312              		.file 26 "../Libraries/ROSSerial/rosserial_msgs/TopicInfo.h"
 313              		.file 27 "../Libraries/ROSSerial/rosserial_msgs/RequestParam.h"
 314              		.file 28 "../Libraries/ROSSerial/std_msgs/Time.h"
 315              		.file 29 "bsp/inc/bsp_led.h"
ARM GAS  /var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s 			page 18


DEFINED SYMBOLS
                            *ABS*:0000000000000000 subscribe_task.cpp
/var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s:17     .text._Z6led_cbPh:0000000000000000 $t
/var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s:24     .text._Z6led_cbPh:0000000000000000 _Z6led_cbPh
      .ARM.extab.text._Z6led_cbPh:0000000000000000 $d
      .ARM.exidx.text._Z6led_cbPh:0000000000000000 $d
/var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s:82     .text._Z24ROS_SubscribeTaskHandlerPKv:0000000000000000 $t
/var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s:89     .text._Z24ROS_SubscribeTaskHandlerPKv:0000000000000000 _Z24ROS_SubscribeTaskHandlerPKv
.ARM.extab.text._Z24ROS_SubscribeTaskHandlerPKv:0000000000000000 $d
.ARM.exidx.text._Z24ROS_SubscribeTaskHandlerPKv:0000000000000000 $d
/var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s:115    .text._Z20rosSubscribeInitTaskPN3ros11NodeHandle_I13STM32HardwareLi5ELi5ELi512ELi512EEE:0000000000000000 $t
/var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s:122    .text._Z20rosSubscribeInitTaskPN3ros11NodeHandle_I13STM32HardwareLi5ELi5ELi512ELi512EEE:0000000000000000 _Z20rosSubscribeInitTaskPN3ros11NodeHandle_I13STM32HardwareLi5ELi5ELi512ELi512EEE
/var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s:257    .text._Z20rosSubscribeInitTaskPN3ros11NodeHandle_I13STM32HardwareLi5ELi5ELi512ELi512EEE:0000000000000098 $d
.ARM.exidx.text._Z20rosSubscribeInitTaskPN3ros11NodeHandle_I13STM32HardwareLi5ELi5ELi512ELi512EEE:0000000000000000 $d
/var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s:267    .rodata:0000000000000000 $d
/var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s:277    .rodata._Z20rosSubscribeInitTaskPN3ros11NodeHandle_I13STM32HardwareLi5ELi5ELi512ELi512EEE.str1.4:0000000000000000 $d
/var/folders/l3/4y5292px21b4835bsnjwqc7w009kq1/T//cc4EZG1E.s:285    .rodata.str1.4:0000000000000000 $d

UNDEFINED SYMBOLS
bsp_LedOff
bsp_LedOn
__aeabi_unwind_cpp_pr1
osDelay
osThreadCreate
__aeabi_unwind_cpp_pr0
